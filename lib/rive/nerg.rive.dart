// ignore_for_file: type=lint
// THIS FILE WAS AUTOMATICALLY GENERATED BY flutter_rive_generator. MODIFICATIONS WILL BE LOST WHEN THE GENERATOR RUNS AGAIN.
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';
import 'package:rive/rive.dart' as rive;
import 'package:rive/src/rive_core/state_machine_controller.dart' as core;

const assetsBaseFolder = "assets";

String _assetPath() {
  return (kIsWeb ? '' : assetsBaseFolder + '/') + 'nerg.riv';
}

class Nerg {
  final rive.RiveFile file;
  static String get assetPath => _assetPath();

  Nerg._(this.file);

  static Future<Nerg> load() async {
    final riveFile =
        rive.RiveFile.import(await rootBundle.load(Nerg.assetPath));
    return Nerg._(riveFile);
  }

  Alla? _alla;
  Alla get alla => _alla ??= Alla(file.artboards
      .where((artboard) => artboard.name == r'alla')
      .elementAt(0));

  Logo? _logo;
  Logo get logo => _logo ??= Logo(file.artboards
      .where((artboard) => artboard.name == r'logo')
      .elementAt(0));
}

class Alla {
  final rive.Artboard artboard;
  Alla(this.artboard);

  AllaStateMachine1StateMachine getAllaStateMachine1StateMachine(
      [core.OnStateChange? onStateChange]) {
    return AllaStateMachine1StateMachine(this
        .artboard
        .stateMachineByName("State Machine 1", onChange: onStateChange)!);
  }
}

abstract class AllaController {
  abstract final rive.RiveAnimationController controller;
}

class AllaSimpleAnimation extends AllaController {
  final rive.RiveAnimationController controller;

  AllaSimpleAnimation(this.controller);
}

class AllaOneShotAnimation extends AllaController {
  final rive.RiveAnimationController controller;

  AllaOneShotAnimation(this.controller);
}

enum AllaAnimations {
  timeline1(r"Timeline 1"),
  change2(r"change 2"),
  changecubic2(r"change cubic 2"),
  changecubic(r"change cubic"),
  change(r"change"),
  expand(r"expand");

  final String name;
  const AllaAnimations(this.name);
  AllaOneShotAnimation makeOneShotAnimation({
    bool autoplay = true,
    double mix = 1,
    void Function()? onStart,
    void Function()? onStop,
  }) {
    return AllaOneShotAnimation(rive.OneShotAnimation(this.name,
        autoplay: autoplay, mix: mix, onStart: onStart, onStop: onStop));
  }

  AllaSimpleAnimation makeSimpleAnimation({
    bool autoplay = true,
    double mix = 1,
  }) {
    return AllaSimpleAnimation(
        rive.SimpleAnimation(this.name, autoplay: autoplay, mix: mix));
  }

  String toString() {
    return this.name;
  }
}

class AllaStateMachine1StateMachine {
  final rive.StateMachineController controller;

  AllaStateMachine1StateMachine(this.controller);
}

class AllaRive extends StatelessWidget {
  final List<AllaAnimations> animations;
  final Alignment? alignment;
  final bool antialiasing;
  final List<AllaController> controllers;
  final BoxFit? fit;
  final Function(Alla artboard)? onInit;
  final Widget? placeHolder;

  const AllaRive({
    super.key,
    this.animations = const [],
    this.alignment,
    this.antialiasing = true,
    this.controllers = const [],
    this.fit,
    this.onInit,
    this.placeHolder,
  });

  @override
  Widget build(BuildContext context) {
    return rive.RiveAnimation.asset(
      _assetPath(),
      animations: animations.map((e) => e.name).toList(),
      alignment: alignment,
      antialiasing: antialiasing,
      artboard: r'alla',
      controllers: this.controllers.map((e) => e.controller).toList(),
      fit: fit,
      onInit: (p0) {
        onInit?.call(Alla(p0));
      },
      placeHolder: placeHolder,
      stateMachines: [],
    );
  }
}

class Logo {
  final rive.Artboard artboard;
  Logo(this.artboard);

  LogoCycleStateMachine getLogoCycleStateMachine(
      [core.OnStateChange? onStateChange]) {
    return LogoCycleStateMachine(
        this.artboard.stateMachineByName("cycle", onChange: onStateChange)!);
  }
}

abstract class LogoController {
  abstract final rive.RiveAnimationController controller;
}

class LogoSimpleAnimation extends LogoController {
  final rive.RiveAnimationController controller;

  LogoSimpleAnimation(this.controller);
}

class LogoOneShotAnimation extends LogoController {
  final rive.RiveAnimationController controller;

  LogoOneShotAnimation(this.controller);
}

enum LogoAnimations {
  n(r"n"),
  e(r"e"),
  r(r"r"),
  g(r"g"),
  idle(r"idle");

  final String name;
  const LogoAnimations(this.name);
  LogoOneShotAnimation makeOneShotAnimation({
    bool autoplay = true,
    double mix = 1,
    void Function()? onStart,
    void Function()? onStop,
  }) {
    return LogoOneShotAnimation(rive.OneShotAnimation(this.name,
        autoplay: autoplay, mix: mix, onStart: onStart, onStop: onStop));
  }

  LogoSimpleAnimation makeSimpleAnimation({
    bool autoplay = true,
    double mix = 1,
  }) {
    return LogoSimpleAnimation(
        rive.SimpleAnimation(this.name, autoplay: autoplay, mix: mix));
  }

  String toString() {
    return this.name;
  }
}

class LogoCycleStateMachine {
  final rive.StateMachineController controller;

  LogoCycleStateMachine(this.controller);
}

class LogoRive extends StatelessWidget {
  final List<LogoAnimations> animations;
  final Alignment? alignment;
  final bool antialiasing;
  final List<LogoController> controllers;
  final BoxFit? fit;
  final Function(Logo artboard)? onInit;
  final Widget? placeHolder;

  const LogoRive({
    super.key,
    this.animations = const [],
    this.alignment,
    this.antialiasing = true,
    this.controllers = const [],
    this.fit,
    this.onInit,
    this.placeHolder,
  });

  @override
  Widget build(BuildContext context) {
    return rive.RiveAnimation.asset(
      _assetPath(),
      animations: animations.map((e) => e.name).toList(),
      alignment: alignment,
      antialiasing: antialiasing,
      artboard: r'logo',
      controllers: this.controllers.map((e) => e.controller).toList(),
      fit: fit,
      onInit: (p0) {
        onInit?.call(Logo(p0));
      },
      placeHolder: placeHolder,
      stateMachines: [],
    );
  }
}
